"""
Pydantic schemas for MealStructureEngine input/output validation.
"""
from typing import Optional, Dict, List, Any
from pydantic import BaseModel, Field, field_validator
import re


class BehavioralPreferences(BaseModel):
    """
    Behavioral preferences for meal structure generation.
    
    All fields are optional with sensible defaults.
    """
    explicit_meal_count: Optional[int] = Field(None, ge=1, le=7, description="User-specified meal count")
    snack_preference: bool = Field(True, description="Whether snacks are preferred")
    liquid_meal_allowed: bool = Field(False, description="Whether liquid meals are allowed")
    fasting_window: Optional[str] = Field(None, description="Fasting window format (e.g., '16:8')")
    max_meals: int = Field(5, ge=1, le=7, description="Maximum number of meals allowed")
    
    @field_validator('fasting_window')
    @classmethod
    def validate_fasting_window(cls, v: Optional[str]) -> Optional[str]:
        """Validate fasting window format (e.g., '16:8')."""
        if v is None:
            return v
        if not re.match(r'^\d+:\d+$', v):
            raise ValueError('Fasting window must be in format "HH:MM" (e.g., "16:8")')
        return v


class ClientScheduleInput(BaseModel):
    """
    Client schedule input extracted from assessment snapshot.
    
    Required fields for meal timing calculation.
    """
    wake_time: str = Field(..., description="Wake time in HH:MM format (24-hour)")
    sleep_time: str = Field(..., description="Sleep time in HH:MM format (24-hour)")
    work_schedule: Optional[Dict[str, str]] = Field(None, description="Work schedule with start and end times")
    
    @field_validator('wake_time', 'sleep_time')
    @classmethod
    def validate_time_format(cls, v: str) -> str:
        """Validate time format is HH:MM (24-hour format)."""
        if not re.match(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$', v):
            raise ValueError('Time must be in HH:MM format (24-hour)')
        return v
    
    @field_validator('work_schedule')
    @classmethod
    def validate_work_schedule(cls, v: Optional[Dict[str, str]]) -> Optional[Dict[str, str]]:
        """Validate work schedule structure."""
        if v is None:
            return v
        if 'start' not in v or 'end' not in v:
            raise ValueError('Work schedule must have "start" and "end" keys')
        # Validate time formats
        for key in ['start', 'end']:
            if not re.match(r'^([01]?[0-9]|2[0-3]):[0-5][0-9]$', v[key]):
                raise ValueError(f'Work schedule {key} must be in HH:MM format (24-hour)')
        return v


class NutritionTargetsInput(BaseModel):
    """
    Nutrition targets input extracted from TargetContext.
    
    Required fields for meal structure generation.
    """
    target_calories: float = Field(..., gt=0, description="Target calories per day")
    target_protein_g: float = Field(..., gt=0, description="Target protein in grams")
    target_carbs_g: Optional[float] = Field(None, gt=0, description="Target carbohydrates in grams")
    target_fat_g: Optional[float] = Field(None, gt=0, description="Target fat in grams")
    priority_macro: Optional[str] = Field(None, description="Priority macro (e.g., 'protein')")
    constraint_flags: List[str] = Field(default_factory=list, description="Constraint flags")


class MealStructureOutput(BaseModel):
    """
    Meal structure output schema.
    
    Validates the structure generated by MealStructureEngine.
    Note: This schema is for validation only. The actual output uses MealStructureContext.
    """
    meal_count: int = Field(..., ge=1, le=7, description="Number of meals")
    meals: List[str] = Field(..., min_length=1, description="List of meal names")
    timing_windows: Dict[str, List[str]] = Field(..., description="Timing windows for each meal")
    energy_weight: Dict[str, float] = Field(..., description="Relative allocation weights (sum = 1.0)")
    flags: List[str] = Field(default_factory=list, description="Flags indicating adjustments or warnings")
    
    @field_validator('meals')
    @classmethod
    def validate_meals_match_count(cls, v: List[str], info) -> List[str]:
        """Validate that meal count matches number of meals."""
        if 'meal_count' in info.data and len(v) != info.data['meal_count']:
            raise ValueError(f'Number of meals ({len(v)}) must match meal_count ({info.data["meal_count"]})')
        return v
    
    @field_validator('timing_windows', 'energy_weight')
    @classmethod
    def validate_meal_keys_match(cls, v: Dict[str, Any], info) -> Dict[str, Any]:
        """Validate that all meal keys exist in meals list."""
        if 'meals' in info.data:
            meals = set(info.data['meals'])
            for key in v.keys():
                if key not in meals:
                    raise ValueError(f'Meal key "{key}" not found in meals list')
        return v
    
    @field_validator('energy_weight')
    @classmethod
    def validate_energy_weight_sum(cls, v: Dict[str, float]) -> Dict[str, float]:
        """Validate that energy weights sum to 1.0 (Â±0.01 tolerance)."""
        total = sum(v.values())
        if abs(total - 1.0) > 0.01:
            raise ValueError(f'Energy weights must sum to 1.0, got {total:.4f}')
        return v

